from categories.analysis import webscanner
from urllib.parse import urlparse, parse_qs, urlencode
import requests
import time
import certifi

class SimpleArgs:
    pass

def get_target_url():
    print("Enter the target URL:")
    target_url = input("> ").strip()

    if not target_url.startswith("http://") and not target_url.startswith("https://"):
        print("[!] URL must start with http:// or https://")
        return get_target_url()

    return target_url


def extract_sqli_candidates(scan_results):
    attack_targets = []
    target_id = 1

    # --- 1. GET URLs from crawler ---
    if "crawler" in scan_results:
        for link in scan_results["crawler"].get("found_links", []):
            parsed = urlparse(link)
            params = parse_qs(parsed.query)

            if params:
                attack_targets.append({
                    "id": target_id,
                    "source": "crawler",
                    "type": "GET",
                    "url": f"{parsed.scheme}://{parsed.netloc}{parsed.path}",
                    "params": params,
                })
                target_id += 1

    # --- 2. Forms from form analyzer ---
    if "forms" in scan_results:
        for form in scan_results["forms"].get("forms", []):
            action = form.get("action")
            inputs = form.get("inputs", [])
            if action and inputs:
                attack_targets.append({
                    "id": target_id,
                    "source": "form",
                    "type": "POST",
                    "url": action,
                    "fields": [i["name"] for i in inputs if i.get("name")],
                })
                target_id += 1

    # --- 3. Fuzzer-confirmed SQLi ---
    if "fuzz" in scan_results:
        for entry in scan_results["fuzz"].get("possible_vulnerabilities", []):
            url = entry.get("url")
            param = entry.get("param")
            if url and param:
                attack_targets.append({
                    "id": target_id,
                    "source": "fuzzer",
                    "type": "GET",
                    "url": url.split("?")[0],
                    "params": {param: "FUZZ"},
                    "fuzzer_flag": True
                })
                target_id += 1

    return attack_targets


def display_sqli_targets(attack_targets):
    print("\n[+] Potential SQL Injection Targets:")
    print("-" * 60)

    for t in attack_targets:
        if t["type"] == "GET":
            params = ", ".join(t["params"].keys())
            print(f"{t['id']}. [GET]  {t['url']}  ? {params}   (source: {t['source']})")

        elif t["type"] == "POST":
            fields = ", ".join(t["fields"])
            print(f"{t['id']}. [POST] {t['url']}  fields: {fields}   (source: {t['source']})")

    print("-" * 60)


def select_target(attack_targets):
    if not attack_targets:
        print("[!] No SQL Injection surfaces found.")
        return None

    while True:
        try:
            choice = int(input("Select target ID > "))
            selected = next(x for x in attack_targets if x["id"] == choice)
            return selected
        except (ValueError, StopIteration):
            print("Invalid choice. Try again.")

def deliver_payload(target, field, payload, timeout=10, session=None):
    if session is None:
        session = requests.Session()

    url = target["url"]

    if target["type"] == "GET":
        params = target["params"].copy()
        params[field] = payload

        start = time.time()
        response = session.get(url, params=params, timeout=timeout, verify=certifi.where())
        elapsed = time.time() - start
        return {
            "url": response.url,
            "method": "GET",
            "sent_field": field,
            "payload": payload,
            "status_code": response.status_code,
            "response_time": round(elapsed, 3),
            "content_length": len(response.text),
            "body_preview": response.text[:300]
        }
    elif target["type"] == "POST":
        data = {}
        for f in target["fields"]:
            data[f] = payload if f == field else "test"

        start = time.time()
        response = session.post(url, data=data, timeout=timeout, verify=certifi.where())
        elapsed = time.time() - start
        return {
            "url": url,
            "method": "POST",
            "sent_field": field,
            "payload": payload,
            "status_code": response.status_code,
            "response_time": round(elapsed, 3),
            "content_length": len(response.text),
            "body_preview": response.text[:300]
        }

def interactive_console(target, session=None):
    print("\n[+] Interactive SQL Injection Console")
    print("Type 'exit' to leave.")
    print("-------------------------------------")

    if target["type"] == "GET":
        fields = list(target["params"].keys())
    else:
        fields = target["fields"]

    print(f"Available fields: {', '.join(fields)}")
    field = input("Inject into which field? > ").strip()

    if field not in fields:
        print("[!] Invalid field selected.")
        return

    while True:
        payload = input("sqli> ").strip()
        if payload.lower() == "exit":
            break

        result = deliver_payload(target, field, payload, session=session)

        print("\n--- Response Summary ---")
        print("URL:", result["url"])
        print("Status Code:", result["status_code"])
        print("Time:", result["response_time"])
        print("Length:", result["content_length"])
        print("Body preview:")
        print(result["body_preview"])
        print("------------------------\n")
       

def run():
    # 1. Ask user for target
    target_url = get_target_url()

    # 2. Prepare arguments for webscanner
    args = SimpleArgs()
    args.url = target_url
    args.method = "all"
    args.timeout = 5
    args.retries = 3
    args.max_workers = 3
    args.delay = 0.5
    args.file = None
    args.output = None
    args.format = None

    # 3. Run all reconnaissance modules
    scan_results = webscanner.run(args)

    # 4. Extract possible SQLi targets
    attack_targets = extract_sqli_candidates(scan_results)

    # 5. Display them
    display_sqli_targets(attack_targets)

    # 6. Let user pick one to attack
    selected = select_target(attack_targets)

    print("\n[+] Selected SQL Injection Target:")
    print(selected)

    # 7. Deliver the payload
    interactive_console(selected)

    return selected
